# 1장 사용자 수에 따른 규모 확장성

수백만 사용자를 지원하는 시스템을 설계하는 것은 도전적인 과제이다.

이번 장에서는 한 명의 사용자를 지원하는 시스템에서 시작하여, 최종적으로는 몇백만 사용자를 지원하는 시스템을 설계해본다.

## 단일 서버

모든 컴포넌트(웹, 앱, 데이터베이스, 캐시)가 한 대의 서버에서 실행되는 간단한 시스템이다.

사용자 요청 처리 흐름


1. DNS 질의
2. 대상 IP 주소로 HTTP 요청
3. 웹서버에서 응답 반환

## 데이터베이스

사용자가 늘면 서버 하나로는 충분하지 않아서 여러 서버를 두어야 함.

하나는 웹/모바일 트래픽 처리용, 하나는 데이터베이스용 (웹 계층, 데이터 계층)

### 어떤 데이터베이스를 사용할 것인가?

전통적인 관계형 데이터베이스와 비-관계형 데이터베이스 사이에서 고를 수 있다.

- 관계형 데이터베이스(RDBMS) : Oracle, MySQL, PostgreSQL 등이 대표적. 자료를 테이블과 Row, Column으로 표현.
- 비관계형 데이터베이스(NoSQL) : MongoDB, Amazon DynamoDB 등이 대표적. NoSQL은 다시 4부류로 나눌 수 있음
    - key-value store
    - graph store
    - column store
    - document store
    - 대부분 RDBMS가 안정적이고 적합하나 NoSQL이 적합한 경우는 아래 경우들이 있을 수 있으므로 고려해보아야 함.
        - 아주 낮은 latency가 요구되는 경우
        - 비정형 데이터인 경우
        - 데이터를 직렬화하거나 역직렬화 할 수 있기만 하면 되는 경우
        - 아주 많은 양의 데이터를 저장할 필요가 있는 경우

## 수직적 규모 확장 vs 수평적 규모 확장

vertical scaling vs horizontal scaling

- 수직적 규모 확장 : scale up 이라고 표현. 개별 인스턴스 또는 서버의 스펙을 올리는 방식
- 수평적 규모 확장 : scale out 이라고 표현. 동일한 스펙의 서버의 수량을 늘리는 방식
- 서버로 유입되는 트래픽의 양이 적을때는 수직적 확장이 좋은 선택이고, 이 방법의 장점은 단순함이다. 몇가지 심각한 단점이 있는데
    - 한계가 있다. 하나의 서버에 램, CPU를 무한대로 꽂을 수 없다.
    - 장애에 대한 자동복구(failover) 방안이나 다중화(redundancy) 방안을 제시해주지 않는다.
    - 이런 단점때문에 대규모 애플리케이션을 지원하는 데는 수평적 규모 확장법이 보다 적절하다.

### 로드밸런서

웹계층에서 여러대의 서버들에 트래픽을 고르게 분배해주는 역할

- 로드밸런서가 아래에 위치한 서버들의 health check를 통해 하나가 다운되거나 비정상이 되면 정상 작동하는 서버로만 트래픽을 보내도록 작동한다.

### 데이터베이스 다중화

- Primary, Secondary구조로 구성
- Write 연산은 Primary에서만, Secondary(read replica)들에서는 primary로부터 replication을 받으면서 read 연산 수행
- 대부분의 애플리케이션은 읽기 비중이 쓰기보다 훨씬 높기 때문에 read replica 수를 많도록 구성한다.

데이터베이스 다중화로 얻는 이득은 아래와 같다.

- 더 나은 성능 : 여러대로 다중화 함으로써 병렬로 처리될 수 있는 쿼리의 수가 늘어나므로 성능이 좋아진다
- 안정성(reliability) : 자연 재해 등의 이유로 데이터베이스 서버 가운데 일부가 파괴되어도 데이터는 보존된다. 여러 지역에 걸쳐 다중화 시킬 수 있다.
- 가용성(availability) : 데이터를 여러 지역에 복제해 둠으로써 하나의 데이터베이스 서버에 장애가 발생하더라도 다른 서버의 데이터를 이용해 계쏙 서비스 할 수 있다.

---

데이터베이스가 여러대일때 일부가 죽으면 어떻게 되는가?

1. Primary가 죽는 경우 : Read replica 중에 한대를 primary로 승격(promote) 시킴으로써 서비스 계속되게 할 수 있다.
2. Secondary(Read replica)가 죽는 경우 : secondary가 여러 대일 경우 분산되므로 상관 없고, 한대인데 죽는 경우 읽기 연산은 한시적으로 주 데이터베이스(primary)로 전달됨.

---

웹 계층과 데이터 계층의 다중화를 고려한 설계는 이렇게 된다.

동작은 아래와 같다.

- 사용자는 DNS로부터 로드밸런서의 공개 IP 주소를 받는다.
- 사용자는 해당 IP 주소를 사용해 로드밸런서를 접속한다.
- 로드밸런서에 의해 사용자의 요청이 서버들 중 한대로 전달된다.
- 읽기 연산일 경우
    - 사용자 데이터를 read replica에서 읽는다
- 쓰기 연산일 경우
    - 사용자 데이터를 primary를 통해 업데이트한다.

## 캐시

- 자주 참조되는 데이터를 메모리 안에 두고 뒤이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소이다.
- 애플리케이션에서 같은 데이터를 계속 데이터베이스에서 꺼내가면 데이터베이스엔 부하가 발생하므로, 기존에 요청됐던 데이터라면 캐시를 통해 가져가도록 구성하는 방안이다.

### 캐시 계층

- 데이터가 잠시 보관되는 곳으로, 데이터베이스보다 훨씬 빠르다.

1. 요청을 받은 웹 서버는 캐시에 응답이 저장되어 있는지 본다.
2. 있으면 캐시에서 읽어 반환하고, 없으면 데이터베이스에서 읽어 캐시에 쓰고 반환한다.
- 이런 caching strategy를 read through 방식이라고 한다.
- 대부분의 캐시 서버들은 프로그래밍 언어로 API를 제공해준다.

### 캐시 사용시 유의할 점

- 데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어나는 경우 유용
- 캐시는 휘발성 메모리(RAM)에 데이터를 두기 때문에 영속적으로 보관되어야 하는 데이터를 캐시에 두는 것은 바람직하지 않음.
- 캐시에 보관된 데이터의 만료 기한 설정은 어떻게 할지 정책을 정해두어야 한다.
    - 만료 기한이 짦을 경우 데이터베이스를 자주 읽어야 해서 데이터베이스에 부하가 생길거고
    - 너무 길면 데이터 정합성이 깨질 수 있다.
- 일관성은 데이터베이스의 데이터와 캐시의 데이터가 같은지 여부이다. 데이터베이스의 원본 데이터를 갱신하는 작업과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되지 않는 경우 일관성(consistency)이 깨질 수 있다.
- 캐시 서버를 한대만 두는 경우 장애 상황에 캐시가 응답이 없어 곤란해질 수 있다.
    - 고로 캐시 서버도 장애를 대비해 여러대를 두어야 한다.
- 캐시 메모리를 얼마나 크게 잡을지에 대한 고민도 필요하다.
- 캐시에 저장된 데이터의 eviction은 어떻게 할 것인가?
    - LRU(least recently used) 방식이 가장 보편적으로 쓰인다 (가장 나중에 참조된 데이터를 먼저 내보내는 방식)

## CDN(Content delivery network)

CDN은 정적 콘텐츠를 전송하는 데 쓰이는 지리적으로 분산된 서버의 네트워크이다. 이미지, 비디오, css, javascript 파일 등을 캐싱할 수 있다.

CDN은 개략적으로 아래와 같이 동작한다.

- 어떤 사용자가 웹사이트를 방문하면 그 사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠를 전달하게 된다.
- 사용자가 CDN 서버로부터 물리적으로 멀면 멀수록 웹사이트가 천천히 로드된다.

### CDN 사용시 고려해야 할 사항

- 비용 : CDN으로 들어오고 나가는 데이터 전송량에 따라 과금된다.
- 만료 시한 설정 : time sensitive 한 컨텐츠일 경우 만료 시점을 잘 정해야 한다. 너무 길면 사용자들이 예전 컨텐츠를 볼 가능성이 커진다.
- CDN 장애에 대한 대처 방안 : CDN에 장애가 발생시 페이지 상에서 해당 영역들은 엑박이 뜰텐데 이럴떄 어떻게 할지 준비해둬야 한다
- 컨텐츠 invalidation 방법 : 정적 웹사이트의 경우 새로 배포할때마다 무효화(CDN 캐시에 저장된 데이터를 비움) 하는 식으로 구성함.

---

처음의 설계에서 CDN, 캐시가 추가되면 아래와 같이 구성된다.

1. 정적 컨텐츠(js, css, 이미지 등)은 웹서버를 통해 서빙되지 않고 CDN에서 서빙해준다.
2. 캐시가 데이터베이스 부하를 줄여준다.

## stateless 웹 계층

- 이커머스 서비스의 장바구니 서비스를 만든다고 생각해보자 (무식한 예시)
- 고가용성을 위해 여러대의 서버를 구성해서 제공해야 한다.
- 사용자는 현재 A라는 서버를 통해 서비스를 이용중이다.
    - 사용자가 장바구니에 원하는 제품을 담았다고 가정하자. 이 장바구니 보관 항목에 대한 상태는 A 서버에 저장해두게 된다.
    - 이때 사용자 컴퓨터가 꺼져서 다시 켜서 웹사이트에 접근했다. 이번에는 로드밸런서가 사용자를 B서버로 서비스 이용하도록 요청을 보내줬다.
    - 이때 사용자 A가 장바구니에 담아뒀던 항목은 A서버에만 있기 때문에 B서버 통해 붙었을 경우 장바구니가 비어있는 것으로 사용자는 보게된다.
- 이렇게 개별 서버들이 상태를 보관하는 구조에서는 골치가 아파진다

---

이런 문제들을 안겪을 수 있는, 개별 서버들이 상태를 보관하지 않는 stateless 한 구성은 아래와 같이 할 수 있다.

- 상태 데이터는 memcached, redis 같은 캐시 서버들을 통해 보관하도록 할 수도 있고(스프링 클러스터였나 같은건 요즘 잘 안쓰는걸로 알고있으요) NoSQL 이용하도록 구성할 수도 있다.

## 데이터센터

전세계 어디서도 사이트가 잘 접속되도록 하려면 데이터센터 단위에서의 이중화가 필요하다. 이때 고려되어야 할 것은

1. 사용자가 가까운 위치의 데이터센터를 통해 요청을 보내고 처리되도록 한다.
2. 하나의 데이터센터가 먹통이 되는 경우 나머지 데이터센터를 통해 사용자들의 요청이 처리되도록 한다.

이렇게 하려면 풀어야 할 기술적 난제는

- 트래픽 우회(geolocation based traffic routing)
- 데이터 동기화 - 여러 데이터센터에 데이터베이스, 스토리지 같은 서버들이 산재된 경우 어떻게 서로 동기화하도록 할지
- 테스트와 배포 : 애플리케이션이 여러 데이터센터 통해 잘 작동하는지 테스트 어떻게 할지에 대한 고민, 배포는 어떻게 여러 데이터센터로 할지 등에 대한 고민이 필요

---

시스템이 더 큰 규모로 확장하기 위해서는 시스템의 컴포넌트들을 분리하고 각 영역들이 독립적으로 확장될 수 있도록 해야 한다. 메세지 큐 서버를 구성해서 분산 시스템을 구현할 수 있다.

## 메세지 큐

- 서비스의 여러 컴포넌트들이 분리된 설계에서는 메세지 큐를 통해 각 서비스들이 데이터를 주고받게 하여 느슨한 결합이 가능하도록 할 수 있다.
- 이렇게 하면 개별 컴포넌트들에 대해서만 따로 확장하도록 구성하여 애플리케이션 안정성을 추구할 수 있다.

## 로그, 메트릭 그리고 자동화

서비스 규모가 커지면 로그, 메트릭의 수집을 통해 서비스 안정성을 관찰하는 것이 중요해진다. 그리고 자동화를 통해 반복 작업으로 인해 소요되는 인력들의 시간을 아낄 수 있다.

---

메세지 큐, 로그 그리고 메트릭 수집, 자동화 등을 반영한 설계안은 아래와 같다.

## 데이터베이스의 규모 확장

- 수직적 확장, 수평적 확장 중 수평적 확장이 대규모 시스템에 유리하다.
- 샤딩은 데이터베이스에 보관되는 데이터를 샤드라는 단위로 분리하여 저장하도록 하는 기술이다
    - 샤딩을 사용할 때 샤딩 키의 설정이 성능에 중요한 영향을 미친다.
    - 샤딩키는 partition key라고도 불린다.
        - 키의 범위에 따라 샤드 partition이 나뉜다.
    - 샤딩은 데이터베이스 규모 확장을 실현하는 좋은 기술이지만 완벽하진 않다. 도입하면 풀어야할 어려움들이 발생하기 때문인데
        - 데이터의 재 샤딩이 필요한 경우가 발생할 수 있다.
            - 데이터가 너무 많아져서 하나의 샤드로는 더이상 감당하기 어려울때
            - 샤드간 데이터 분포가 균등하지 못해 어떤 샤드에 할당된 공간 소모가 다른 샤드에 비해 빠르게 진행될 때
            - 데이터 재배치가 필요해지는데, 시간이라는 비용이 크게 소요될 수 있다.
        - 유명인사(celebrity) 문제 : 특정 파티션이 인기있어 자주 참조되는 경우(hot partition) 해당 서버에만 부하가 걸리는 경우이다.
            - 이런 경우 hot partition에 저장되는 데이터를 여러 shard에 고르게 배치해줘야 문제가 되지 않을 것이다.
        - 조인과 정규화 : 하나의 데이터베이스를 여러 샤드 서버로 쪼개면 여러 샤드에 걸친 데이터의 조인이 힘들어진다.
            - 해결하려면 데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 하는 방법이 있다.

---

샤딩을 적용한 설계는 아래와 같이 된다.

## 백만 사용자, 그리고 그 이상

- 시스템의 규모를 확장하는 것은 지속적이고 반복적인 과정이다.
- 이번 장에서 살펴본 기법들은 아래와 같다.
    - 웹 계층은 stateless 하도록 구현
    - 모든 계층에 다중화 도입
    - 가능한 한 많은 데이터를 캐싱하도록
    - 지리적으로 분산된 여러 데이터센터를 구성할 것
    - 정적 콘텐츠는 CDN을 통해 서비스할 것
    - 데이터 계층은 샤딩을 통해 그 규모를 확장할 것
    - 각 계층은 독립적 서비스로 분할할 것
    - 시스템을 지속적으로 모니터링하고 자동화 도구들을 활용할 것