# [6장] 키 값 저장소 설계

- 분산 키 값 저장소 설게시 일관성, 가용성, 파티션 감내성을 고려해야 한다.
  + 일관성: 모든 클라이언트는 접속한 노드에 관계 없이 동일한 데이터를 봐야 함
  + 가용성: 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 함
  + 파티션 감내성: 파티션(네트워크 장애)이 발생해도 시스템은 계속 동작해야 함
- 요구 사항에 맞게 일관성과 가용성을 선택
  + 은행의 경우 일관성을 포기하지 않음, 데이터 불일치를 피하기 위해 쓰기 연산을 중단할 경우 가용성이 깨진다

- 키 값 저장소 구현에 사용될 시스템 컴포넌트
  + 데이터 파티션
    + 대규모 어플리케이션의 경우 데이터를 한 서버에 넣는 것은 불가능 하므로 데이터를 분할하여 여러대의 서버에 저장
    + 데이터를 여러 노드에 저장할 수 있는지? 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화 할 수 있는지?
  + 데이터 다중화
    + 데이터를 N개의 서버에 비동기적으로 다중화 함으로써 가용성과 안정성 확보
    + N은 튜닝 가능한 값이며, 같은 물리 서버에 저장하는 것은 피하는 것이 좋음
  + 데이터 일관성
    + 여러 노드에 다중화된 데이터는 적절히 동기화 되어야 함
    + N = 사본 개수, R = 읽기 연산 정족수, W = 쓰기 연산 정족수
    + W 의 값이 작을 수록 빠른 쓰기 연산에 최적화, W + R > N 이면 강한 일관성 보장
    + 강한 일관성: 모든 읽기 연산은 최근에 갱신된 결과를 반환, 모든 사본에 연산의 결과가 반영될 때 까지 읽기/쓰기 금지
    + 약한 일관성: 읽기 연산이 최근에 갱신된 결과를 반환하지 못할 수 있음
    + 최종 일관성: 갱신 결과가 결국에는 모두 동기화 되는 모델
  + 비 일관성 해소 기법: 데이터 버저닝, 벡터 시계
    + 데이터 버저닝: 데이터를 변경할 때 마다 해당 데이터의 버전을 새로 만드는 것
    + 벡터 시계: [서버, 버전]의 순서쌍을 데이터에 매단 것, 선행 버전, 후행 버전, 충돌 여부 판단
    + 예시 그림: 2개의 클라이언트가 동시에 값을 읽고 갱신할 경우, 서로 버전의 데이터가 생성되므로, 그 다음 클라이언트가 충돌 여부를 알 수 있음
    + 클라이언트가 D3 을 읽을지, D4을 읽을지 어떻게 아는거지?
  + 장애 감지
    + 분산형 장애 감지 솔루션 (가십 프로토콜)이 좋다
    + 각 노드는 멤버십 목록을 관리하는데, 다른 노드들의 ID와 하트비트 카운트, 최종 시간이 포함된 목록이다
    + 각 노드는 주기적으로 자신의 박동을 증가하고 무작위로 자신의 박동을 보내고 목록을 갱신한다
    + 어떤 멤버의 박동 값이 지정된 시간동안 갱신되지 않으면 장애로 판단
  + 장애 처리
    + 데이터 사본 간 망가진 상태를 탐지하기 위해서 머클 트리 사용
    + 각 노드에 보관된 값의 해시 값을 비교해서 최종적으로 일관성이 망가진 데이터를 찾는 방법
    + 루트 노드의 해시값부터 비교하여 내려오면서 최종적으로 찾는다

  + 시스템 아키텍쳐
    + 카산드라:  아파치 카산드라(Apache Cassandra)는 자유 오픈 소스 분산형 노에스큐엘(NoSQL) 데이터베이스 관리 시스템(DBMS)의 하나로, 단일 장애 점 없이 고성능을 제공하면서 수많은 서버 간의 대용량의 데이터를 관리하기 위해 설계되었다.
    + sstable(sorted string table): "segment files"이다. 각 segment 안은 key로 정렬된 key-value들이 저장되있고, 한 segment 안에는 unique한 key만 가질 수 있다. 또한, 당연히 value가 여러번 바뀔 수 있으니까 내부적으로 value에 timestamp 칼럼을 추가로 갖고 있을 것이다
    + 블룸 필터(Bloom filter)는 원소가 집합에 속하는지 여부를 검사하는데 사용되는 확률적 자료 구조


# [7장] 분산 시스템을 위한 유일 ID 생성기 설계

- 다중 마스터 복제	
  + 데이버 베이스의 auto increment 기능 활용, 데이버 베이스 개수 만큼 늘린다
  + 서버 추가 삭제시 잘 동작하기 힘들 수 있다. 데이터 센터가 많으면 힘들 수 있다.

- UUID
  + 128비트의 수, 충돌 가능성이 매우 낮음, 서버간 조율 없이 독립적으로 생성 가능
  + 단순하게 만들 수 있지만, 시간 순으로 정렬할 수 없고, 128비트로 길다

- 티켓 서버
  + 자동 증가 기능을 제공하는 디비를 중앙 집중형으로 사용
  + 구현하기 쉽고 중소 규모 앱에 적합하다
  + 티켓 서버가 단일 실패 지점이 된다

- 트위터 스노플레이크 접근법	
  + 여러가지로 나눠서 분산 환경에서 적용 가능 함


# [8장] URL 단축기 설계
- API 엔드 포인트
  + 클라이언트는  API 엔드포인트를 통해 서버와 통신한다.
  + 301 : 영구 이전, 응답을 캐시하여 브라우저가 알아서 캐시된 URL로 요청 보냄 (응답코드는 다 다르지 않나??)
  + 302 :클라이언트의 요청은 단축 URL 서버에 먼저 보내진 후에 원래 URL로 리디렉션
- base 62 사용하는 방법과 해시를 사용하는 방법이 있음
