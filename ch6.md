# 6장 키-값 저장소 설계

- 키-값 저장소(key-value store) 는 키-값 데이터베이스라고도 불리는 비 관계형(non-relational) 데이터베이스이다.

- 이 저장소에 저장되는 값은 고유 식별자(identifier)를 키로 가져야 한다.

- 키와 값 사이의 이런 연결 관계를 키-값 쌍(pair) 라고 지칭한다.

- key는 유일해야 하며, 값은 key를 통해서만 접근할 수 있다.

<br />

## 단일 서버 키-값 저장소

한 대 서버만 사용하는 키-값 저장소를 설계하는 것은 쉽다. 키-값 쌍 전부를 해쉬 테이블에 저장하는 것.

빠른 속도를 보장하지만 모든 데이터를 메모리안에 저장할 수 없다는 약점을 가지고 있다.

이를 위한 개선책으로는

- 데이터 압축
- 자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장

그러나 위와 같은 방법을 통해 개선한다고 해도 한 대 서버로 부족한 순간이 찾아온다.

많은 데이터를 저장하려면 분산 키-값 저장소(distributed key-value store)를 만들 필요가 있다.

<br />

## 분산 키-값 저장소

분산 해시 테이블이라고도 불린다. 키-값 쌍을 여러 서버에 분산시키는 탓이다.

<br />

## CAP 정리

CAP 정리는 데이터 일관성(consistency), 가용성(availability), 파티션 감내(partion tolerance)라는

세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다는 정리다.

- 데이터 일관성 : 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 한다.

- 가용성 : 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다.

- 파티션 감내 : 파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미한다. 네트워크에 파티션이 생기더라도 시스템은 계속 동작하여야 한다는 것을 의미한다.

키-값 저장소는 위의 세 가지 요구사항중 어느 두 가지를 만족하느냐에 따라 다음과 같이 분류할 수 있다.

- CP 시스템 : 일관성과 파티션 감내를 지원하는 키-값 저장소, 가용성을 희생한다.
- AP 시스템 : 가용성과 파티션 감내를 지원하는 키-값 저장소, 데이터 일관성을 희생한다.
- CA 시스템 : 일관성과 가용성을 지원하는 키-값 저장소, 데이터 일관성을 희생한다. 실세계에 존재 x

<br />

# 7장 분산 시스템을 위한 유일 ID 생성기 설계

분산 시스템에서 유일성이 보장되는 ID를 만드는 방법은 여러 가지다.

- 다중 마스터 복제(multi-master replication)
  - DB의 auto_increment 기능을 사용
  - +1 증가가 아니고 k만큼 증가 -> k는 사용중인 DB서버 갯수
  - 단점
    - 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다.
    - ID의 유일성은 보장되지만, 그 값이 시간 흐름에 맞추어 커지도록 보장할 수는 없다.
    - 서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어렵다.
- UUID(Universally Unique Identifier)

  - 128비트 숫자이며, 32자리 16진수로 표현
  - 장점
    - 만들기 쉽고 동기화 이슈도 없다.
    - 각 서버가 자기가 쓸 ID를 알아서 만드는 구조이므로 규모 확장도 쉽다.
  - 단점
    - ID가 128비트로 길다.
    - ID를 시간순으로 정렬할 수 없다.
    - ID에 숫자(numeric)아닌 값이 포함될 수 있다.

- 티켓 서버(ticket server)
  - auto_increment 기능만 수행하는 db서버 즉 티켓서버를 중앙 집중형으로 하나만 사용하는 것.
  - 장점
    - 유일성이 보장되는 숫자로만 구성된 ID를 쉽게 만들 수 있다.
    - 구현하기 쉽고, 중소 규모 애플리케이션에 적합하다.
  - 단점
    - 티켓 서버가 SPOF(Single-Point-of-failure)가 된다.
- 트위터 스노우플레이크(twitter snowflake) 접근법
  - 64비트 ID를 역할별로 쪼개서 구성
  - 사인(sign) 비트 : 1비트를 할당, 나중을 위해 유보
  - 타임스탬프(timestamp) : 41비트 할당, epoch 이후로 몇 밀리초가 경과했는지 나타냄
  - 데이터센터 ID : 5비트 할당, 2^5 = 32개 데이터 센터 지원 가능
  - 서버 ID : 5비트 할당, 데이터 센터당 32개 서버를 사용할 수 있다.
  - 일련번호 : 12비트 할당, 각 서버에서 ID 생성시 이 일련번호를 1만큼 증가, 이 값은 1밀리초가 경과할 때마다 0으로 초기화

<br />

# 8장 URL 단축기 설계

클라이언트가 단축 URL로 접속 -> 단축URL 서버에서 원래 URL로 바꿔서 응답 헤더에 넣어서 내려줌 -> 클라이언트는 응답 받은 원래 URL로 접속

- 301 Permanently Moved : 해당 URL에 대한 HTTP 요청의 처리 책임이 영구적으로 Location 헤더에 반환된 URL로 이전되었다는 응답.
  브라우저는 이 응답을 캐시한다.

- 302 Found : 이 응답은 주어진 URL로의 요청이 일시적으로 Location 헤더가 지정하는 URL에 의해 처리되어야 한다는 응답.

URL 리디렉션을 구현하는 가장 직관적인 방법은 해시 테이블을 이용하는 것이다. 단축 URL, 원래 URL 쌍으로 지정

<br />

## URL 단축

URL을 단축시킬 해시 함수는 다음 요구사항을 만족해야 한다.

- 입력값이 다르면 해시 값도 달라야 한다.
- 해시 값은 원래 URL로 복원 가능해야 한다.

<br />

## 해시 함수 구현에 쓰일 기술

| 해시 후 충돌 해소 전략                                                                    | base-62 변환                                                                                                                 |
| ----------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| 단축 URL의 길이가 고정됨                                                                  | 단축 URL의 길이가 가변적, ID값이 커지면 같이 길어짐                                                                          |
| 유일성이 보장되는 ID 생성기가 필요치 않음                                                 | 유일성 보장 ID 생성기가 필요                                                                                                 |
| 충돌이 가능해서 해소 전략이 필요                                                          | ID의 유일성이 보장된 후에야 적용 가능한 전략이라 충돌은 아예 불가능                                                          |
| ID로부터 단축 URL을 계산하는 방식이 아니라서 다음에 쓸 수 있는 URL을 알아내는 것이 불가능 | ID가 1씩 증가하는 값이라고 가정하면 다음에 쓸 수 있는 단축 URL이 무엇인지 쉽게 알아낼 수 있어서 보안상 문제가 될 소지가 있음 |
